# Database Schema Changes - UUID Separation

## Overview
Updated the database schema to properly separate system identity (UUID) from provider identity (text), following best practices for multi-provider authentication systems.

## Problem Statement
The original schema used `user_id` for both:
1. System-level user identification (should be UUID)
2. Provider-specific user IDs (could be text like "demo-123")

This caused issues when:
- Demo mode generated text IDs like `demo-1234567890-abc123`
- Database expected UUID format
- Type mismatches between authentication providers

## Solution

### New Schema Design
```
user_uuid (uuid)     - System identity, generated by database
provider_uid (text)  - Provider-specific ID (Firebase UID, demo ID, etc.)
```

## Migration

### Step 1: Add New Columns
```sql
ALTER TABLE job_descriptions
  ADD COLUMN IF NOT EXISTS user_uuid uuid DEFAULT gen_random_uuid(),
  ADD COLUMN IF NOT EXISTS provider_uid text;

ALTER TABLE resumes
  ADD COLUMN IF NOT EXISTS user_uuid uuid DEFAULT gen_random_uuid(),
  ADD COLUMN IF NOT EXISTS provider_uid text;
```

### Step 2: Backfill Data
```sql
UPDATE job_descriptions
SET provider_uid = user_id::text
WHERE provider_uid IS NULL AND user_id IS NOT NULL;

UPDATE resumes
SET provider_uid = user_id::text
WHERE provider_uid IS NULL AND user_id IS NOT NULL;
```

### Step 3: Add Indexes
```sql
CREATE INDEX IF NOT EXISTS idx_job_descriptions_user_uuid
  ON job_descriptions(user_uuid);

CREATE INDEX IF NOT EXISTS idx_job_descriptions_provider_uid
  ON job_descriptions(provider_uid);

CREATE INDEX IF NOT EXISTS idx_resumes_user_uuid
  ON resumes(user_uuid);

CREATE INDEX IF NOT EXISTS idx_resumes_provider_uid
  ON resumes(provider_uid);
```

## Updated Table Structures

### job_descriptions
```sql
CREATE TABLE job_descriptions (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  title text NOT NULL,
  description text NOT NULL,
  required_skills text[] DEFAULT '{}',
  embedding vector(384),
  created_at timestamptz DEFAULT now(),

  -- Original (kept for backward compatibility)
  user_id uuid REFERENCES auth.users(id) ON DELETE CASCADE,

  -- New columns
  user_uuid uuid DEFAULT gen_random_uuid(),
  provider_uid text
);
```

### resumes
```sql
CREATE TABLE resumes (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  job_description_id uuid REFERENCES job_descriptions(id) ON DELETE CASCADE,
  candidate_name text DEFAULT 'Unknown',
  file_name text NOT NULL,
  file_url text,
  raw_text text NOT NULL,
  extracted_skills text[] DEFAULT '{}',
  embedding vector(384),
  created_at timestamptz DEFAULT now(),

  -- Original (kept for backward compatibility)
  user_id uuid REFERENCES auth.users(id) ON DELETE CASCADE,

  -- New columns
  user_uuid uuid DEFAULT gen_random_uuid(),
  provider_uid text
);
```

## Frontend Changes

### Auth Utility (`src/utils/auth.ts`)

**Old Interface:**
```typescript
interface AuthResult {
  userId: string | null;
  session: any;
  isDemo: boolean;
}
```

**New Interface:**
```typescript
interface AuthResult {
  userUuid: string | null;      // System UUID (or null for demo)
  providerUid: string | null;    // Provider ID (or null for demo)
  session: any;
  isDemo: boolean;
  provider: 'supabase' | 'demo';
}
```

### Database Inserts

**Old Pattern:**
```typescript
await supabase
  .from('job_descriptions')
  .insert({
    title,
    description,
    user_id: userId,  // Could be UUID or text - problematic!
  });
```

**New Pattern:**
```typescript
const insertData: any = {
  title,
  description,
  provider_uid: providerUid,  // Always text, nullable
};

if (userUuid) {
  insertData.user_uuid = userUuid;  // Always UUID, nullable
}

await supabase
  .from('job_descriptions')
  .insert(insertData);
```

## Backend Changes (Edge Function)

### Authentication Middleware

**Old:**
```typescript
let userId: string | null = null;

if (demoKey === DEMO_API_KEY) {
  isDemoMode = true;
  // userId remains null - but this caused issues
}
```

**New:**
```typescript
let userUuid: string | null = null;
let providerUid: string | null = null;

if (demoKey === DEMO_API_KEY) {
  isDemoMode = true;
  userUuid = null;        // No system UUID in demo mode
  providerUid = null;     // No provider UID in demo mode
} else if (authHeader) {
  const { user } = await supabase.auth.getUser(token);
  userUuid = user.id;     // System UUID from Supabase
  providerUid = user.id;  // Provider UID (same for Supabase)
}
```

### Database Operations

**Old Pattern:**
```typescript
.insert({
  ...data,
  user_id: isDemoMode ? null : userId,
})
```

**New Pattern:**
```typescript
const insertData: any = {
  ...baseData,
  provider_uid: providerUid,
};

if (userUuid) {
  insertData.user_uuid = userUuid;
}

await supabase.from('table').insert(insertData);
```

## Benefits

### 1. Type Safety
- System UUIDs always UUID type
- Provider IDs always text type
- No type casting or coercion needed

### 2. Flexibility
- Support multiple auth providers
- Demo mode works without UUIDs
- Future-proof for OAuth providers

### 3. Data Integrity
- Database constraints enforced
- No invalid UUID errors
- Clear separation of concerns

### 4. Query Optimization
- Proper indexes on both fields
- Efficient lookups by system ID or provider ID

## Usage Patterns

### Authenticated User Flow
```
User logs in with Supabase
  ↓
System generates: userUuid = "a1b2c3d4-..."
                  providerUid = "a1b2c3d4-..." (same)
  ↓
Data stored with both UUIDs
  ↓
Queries use provider_uid for ownership checks
```

### Demo Mode Flow
```
User enters demo mode
  ↓
System sets: userUuid = null
             providerUid = null
  ↓
Database generates random user_uuid via DEFAULT
  ↓
Data stored without provider association
  ↓
Queries work without provider checks
```

### Future OAuth Flow
```
User logs in with Firebase/Auth0/etc
  ↓
System assigns: userUuid = gen_random_uuid()
                providerUid = "firebase:abc123"
  ↓
Data linked by userUuid internally
providerUid tracks original provider
```

## Backward Compatibility

### Maintained Fields
- `user_id` column still exists
- Can be used for legacy queries
- Gradually phase out over time

### Migration Path
1. ✅ Add new columns
2. ✅ Backfill existing data
3. ✅ Update application code
4. ✅ Deploy Edge Functions
5. ⏳ Monitor for issues
6. ⏳ Eventually remove old `user_id` column

## Rollback Plan

If issues occur:

### Database
```sql
-- Restore queries to use user_id
ALTER TABLE job_descriptions DROP COLUMN user_uuid;
ALTER TABLE job_descriptions DROP COLUMN provider_uid;
```

### Application
```
1. Revert src/utils/auth.ts to old interface
2. Revert App.tsx to use userId
3. Revert Edge Function to use userId
4. Redeploy
```

## Testing Checklist

- [x] Demo mode works without UUIDs
- [x] Authenticated users get proper UUIDs
- [x] Database inserts succeed
- [x] Database queries return correct data
- [x] TypeScript compilation passes
- [x] Production build succeeds
- [x] No type errors in console

## Security Considerations

### Demo Mode
- No provider_uid = anonymous data
- user_uuid still generated for internal tracking
- RLS policies allow demo access

### Authenticated Mode
- provider_uid enables ownership tracking
- user_uuid provides system-level identity
- RLS can check either field

### Multi-tenancy
- Use provider_uid for user isolation
- Use user_uuid for internal references
- Supports multiple providers per user

## Performance Notes

### Indexes
- Both user_uuid and provider_uid indexed
- Queries optimized for both lookups
- No performance degradation

### Storage
- Additional 40 bytes per row (UUID + text pointer)
- Negligible for typical use cases
- Benefits outweigh storage cost

## Future Enhancements

### Potential Improvements
1. User mapping table for multiple providers
2. Provider metadata storage
3. Provider-specific RLS policies
4. Audit trail with provider information

### Example: User Mapping Table
```sql
CREATE TABLE user_providers (
  user_uuid uuid REFERENCES users(id),
  provider text NOT NULL,
  provider_uid text NOT NULL,
  created_at timestamptz DEFAULT now(),
  PRIMARY KEY (provider, provider_uid)
);
```

This would enable:
- One user, multiple auth providers
- Provider switching
- Consolidated user profiles
